/*
   Line following robot met ESP32 en QTR-8A sensor
   Sensoren: QTR-8A
   Motor driver: L298N (of vergelijkbaar)
   - Linkermotor -> IN1, IN2, ENA
   - Rechtermotor -> IN3, IN4, ENB
*/

#define NUM_SENSORS 8

// Sensor aansluitingen
int sensorPins[NUM_SENSORS] = {36, 39, 25, 34, 35, 26, 32, 33};
int sensorValues[NUM_SENSORS];

// Motor pinnen
#define ENA 13   // PWM links
#define IN1 12
#define IN2 14
#define ENB 27   // PWM rechts
#define IN3 25
#define IN4 26

// Instellingen
int baseSpeed = 150;     // basissnelheid motoren (0-255)
float Kp = 0.1;          // proportionele factor
float Kd = 1.0;          // differentiÃ«le factor

int lastError = 0;

void setup() {
  Serial.begin(115200);

  // Motor pinnen instellen
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  delay(1000);
  Serial.println("Line Following Robot gestart");
}

void loop() {
  // Lees alle sensoren
  long avg = 0;
  long sum = 0;
  for (int i = 0; i < NUM_SENSORS; i++) {
    sensorValues[i] = analogRead(sensorPins[i]);
    int value = map(sensorValues[i], 0, 4095, 0, 1000); // schalen
    avg += (long)value * (i * 1000);  // gewicht
    sum += value;
  }

  int position = 0;
  if (sum > 0) {
    position = avg / sum;   // positie lijn (0 - 7000)
  }

  int error = position - 3500;  // midden is 3500
  int motorCorrection = Kp * error + Kd * (error - lastError);
  lastError = error;

  int leftMotorSpeed = baseSpeed - motorCorrection;
  int rightMotorSpeed = baseSpeed + motorCorrection;

  // Zorg dat waardes binnen bereik blijven
  leftMotorSpeed = constrain(leftMotorSpeed, 0, 255);
  rightMotorSpeed = constrain(rightMotorSpeed, 0, 255);

  // Motoren aansturen
  setMotor(leftMotorSpeed, rightMotorSpeed);

  // Debug
  Serial.print("Positie: ");
  Serial.print(position);
  Serial.print("  Error: ");
  Serial.print(error);
  Serial.print("  L: ");
  Serial.print(leftMotorSpeed);
  Serial.print("  R: ");
  Serial.println(rightMotorSpeed);

  delay(10);
}

void setMotor(int left, int right) {
  // Links
  if (left >= 0) {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
  } else {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
    left = -left;
  }
  analogWrite(ENA, left);

  // Rechts
  if (right >= 0) {
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
  } else {
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, HIGH);
    right = -right;
  }
  analogWrite(ENB, right);
}
